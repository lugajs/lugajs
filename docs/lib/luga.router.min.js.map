{"version":3,"sources":["luga.router.js","luga.router.utils.js","luga.router.Router.js","luga.router.RouteHandler.js","luga.History.js"],"names":["luga","namespace","router","version","isValidRouteHandler","obj","type","path","enter","exit","getPayload","getParams","match","SLASHES_REGEXP","PARAMS_REGEXP","TOKENS","OS","rgx","save","res","RS","RQ","OQ","OR","RR","RP","OP","key","hasOwnProperty","current","id","replace","rRestore","RegExp","replaceTokens","pattern","regexpName","replaceName","utils","compilePath","getParamIds","regex","values","lastIndex","exec","push","extractValues","getParamValues","fragment","shift","index","input","groups","Router","options","CONST","INVALID_ROUTE","INVALID_ADD_ARGUMENTS","DUPLICATE_ROUTE","ENTER","EXIT","extend","Notifier","this","config","rootPath","handlerConstructor","RouteHandler","greedy","pushState","merge","self","currentFragment","routeHandlers","currentHandlers","add","enterCallBack","exitCallBack","payload","arguments","length","addHandler","handlerOptions","enterCallBacks","exitCallBacks","handler","route","undefined","getByPath","string","format","getAll","i","getMatch","filter","element","array","normalizeFragment","inputString","indexOf","substring","normalizeHash","remove","splice","removeAll","resolve","resOptions","matches","handlers","enterOptions","forEach","context","assembleContext","notifyObservers","contextOptions","params","historyState","setup","setupOptions","start","window","addEventListener","onHashChange","onPopstate","stop","removeEventListener","location","hash","event","document","pathname","state","INVALID_PATH_REGEXP","compiledPath","paramsId","apply","ret","test","settings","history","usePushState","navigate","title","historyMethod","newLocation","href"],"mappings":"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","file":"luga.router.min.js","sourcesContent":["/* istanbul ignore if */\r\nif(typeof(luga) === \"undefined\"){\r\n\tthrow(\"Unable to find Luga JS Core\");\r\n}\r\n\r\n/**\r\n * @interface luga.router.IRouteHandler\r\n *\r\n * @property {String} path\r\n *\r\n * Execute registered enter callbacks, if any\r\n * @function\r\n * @name luga.router.IRouteHandler#enter\r\n * @param {luga.router.routeContext} context\r\n *\r\n * Execute registered exit callbacks, if any\r\n * @function\r\n * @name luga.router.IRouteHandler#exit\r\n *\r\n * Return the handler payload, if any\r\n * Return undefined if no payload is associated with the handler\r\n * @function\r\n * @name luga.router.IRouteHandler#getPayload\r\n * @return {luga.router.routeContext|undefined}\r\n *\r\n * Return an object containing an entry for each param and the relevant values extracted from the fragment\r\n * @function\r\n * @name luga.router.IRouteHandler#getParams\r\n * @param {String} fragment\r\n * @return {Object}\r\n *\r\n * Return true if the given fragment matches the Route. False otherwise\r\n * @function\r\n * @name luga.router.IRouteHandler#match\r\n * @param {String}  fragment\r\n * @return {Boolean}\r\n */\r\n\r\n/**\r\n * @typedef {Object} luga.router.IRouteHandler.options\r\n *\r\n * @property {String}           path              Path. Required\r\n * @property {Array.<function>} enterCallBacks    An array of functions that will be called on entering the route. Default to an empty array\r\n * @property {Array.<function>} exitCallBacks     An array of functions that will be called on exiting the route. Default to an empty array\r\n * @property {Object} payload                     An arbitrary object to be passed to callBacks every time they are invoked. Optional\r\n */\r\n\r\n/**\r\n * @typedef {Object} luga.router.routeContext\r\n *\r\n * @property {String} fragment                Route fragment. Required\r\n * @property {String} path                    Route path. Required\r\n * @property {Object} params                  Object containing an entry for each param and the relevant values extracted from the fragment\r\n * @property {0bject|undefined} payload       Payload associated with the current IRouteHandler. Optional\r\n * @property {0bject|undefined} historyState  Object associated with a popstate event. Optional\r\n *                                            https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate\r\n */\r\n\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\tluga.namespace(\"luga.router\");\r\n\tluga.router.version = \"0.6.0\";\r\n\r\n\t/**\r\n\t * Return true if the given object implements the luga.router.IRouteHandler interface. False otherwise\r\n\t * @param {*} obj\r\n\t * @return {Boolean}\r\n\t */\r\n\tluga.router.isValidRouteHandler = function(obj){\r\n\t\tif(luga.type(obj) === \"object\"){\r\n\t\t\tif((luga.type(obj.path) === \"string\") &&\r\n\t\t\t\t(luga.type(obj.enter) === \"function\") &&\r\n\t\t\t\t(luga.type(obj.exit) === \"function\") &&\r\n\t\t\t\t(luga.type(obj.getPayload) === \"function\") &&\r\n\t\t\t\t(luga.type(obj.getParams) === \"function\") &&\r\n\t\t\t\t(luga.type(obj.match) === \"function\")){\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\n}());","(function(){\r\n\t\"use strict\";\r\n\r\n\tluga.namespace(\"luga.router.utils\");\r\n\r\n\t/*\r\n\t Lovingly adapted from Crossroads.js\r\n\t https://millermedeiros.github.io/crossroads.js/\r\n\t */\r\n\r\n\t// Leading and trailing slashes\r\n\tconst SLASHES_REGEXP = /^\\/|\\/$/g;\r\n\r\n\t// Params:  everything between \"{ }\" or \": :\"\r\n\tconst PARAMS_REGEXP = /(?:\\{|:)([^}:]+)(?:\\}|:)/g;\r\n\r\n\t// Save params during compile (avoid escaping things that shouldn't be escaped)\r\n\tconst TOKENS = {\r\n\t\tOS: {\r\n\t\t\t// Optional slashes\r\n\t\t\t// Slash between \"::\" or \"}:\" or \"\\w:\" or \":{?\" or \"}{?\" or \"\\w{?\"\r\n\t\t\trgx: /([:}]|\\w(?=\\/))\\/?(:|(?:\\{\\?))/g,\r\n\t\t\tsave: \"$1{{id}}$2\",\r\n\t\t\tres: \"\\\\/?\"\r\n\t\t},\r\n\t\tRS: {\r\n\t\t\t// Required slashes\r\n\t\t\t// Used to insert slash between \":{\" and \"}{\"\r\n\t\t\trgx: /([:}])\\/?(\\{)/g,\r\n\t\t\tsave: \"$1{{id}}$2\",\r\n\t\t\tres: \"\\\\/\"\r\n\t\t},\r\n\t\tRQ: {\r\n\t\t\t// Required query string: everything in between \"{? }\"\r\n\t\t\trgx: /\\{\\?([^}]+)\\}/g,\r\n\t\t\t// Everything from \"?\" till \"#\" or end of string\r\n\t\t\tres: \"\\\\?([^#]+)\"\r\n\t\t},\r\n\t\tOQ: {\r\n\t\t\t// Optional query string: everything in between \":? :\"\r\n\t\t\trgx: /:\\?([^:]+):/g,\r\n\t\t\t// Everything from \"?\" till \"#\" or end of string\r\n\t\t\tres: \"(?:\\\\?([^#]*))?\"\r\n\t\t},\r\n\t\tOR: {\r\n\t\t\t// Optional rest: everything in between \": *:\"\r\n\t\t\trgx: /:([^:]+)\\*:/g,\r\n\t\t\tres: \"(.*)?\" // Optional group to avoid passing empty string as captured\r\n\t\t},\r\n\t\tRR: {\r\n\t\t\t// Rest param: everything in between \"{ *}\"\r\n\t\t\trgx: /\\{([^}]+)\\*\\}/g,\r\n\t\t\tres: \"(.+)\"\r\n\t\t},\r\n\t\t// Required/optional params should come after rest segments\r\n\t\tRP: {\r\n\t\t\t// Required params: everything between \"{ }\"\r\n\t\t\trgx: /\\{([^}]+)\\}/g,\r\n\t\t\tres: \"([^\\\\/?]+)\"\r\n\t\t},\r\n\t\tOP: {\r\n\t\t\t// Optional params: everything between \": :\"\r\n\t\t\trgx: /:([^:]+):/g,\r\n\t\t\tres: \"([^\\\\/?]+)?\\/?\"\r\n\t\t}\r\n\t};\r\n\r\n\tfor(let key in TOKENS){\r\n\t\t/* istanbul ignore else */\r\n\t\tif(TOKENS.hasOwnProperty(key) === true){\r\n\t\t\tconst current = TOKENS[key];\r\n\t\t\tcurrent.id = \"__LUGA_\" + key + \"__\";\r\n\t\t\tcurrent.save = (\"save\" in current) ? current.save.replace(\"{{id}}\", current.id) : current.id;\r\n\t\t\tcurrent.rRestore = new RegExp(current.id, \"g\");\r\n\t\t}\r\n\t}\r\n\r\n\tconst replaceTokens = function(pattern, regexpName, replaceName){\r\n\t\tfor(let key in TOKENS){\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif(TOKENS.hasOwnProperty(key) === true){\r\n\t\t\t\tconst current = TOKENS[key];\r\n\t\t\t\tpattern = pattern.replace(current[regexpName], current[replaceName]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn pattern;\r\n\t};\r\n\r\n\t/**\r\n\t * Turn a path into a regular expression\r\n\t * @param {String} path\r\n\t * @return {RegExp}\r\n\t */\r\n\tluga.router.utils.compilePath = function(path){\r\n\r\n\t\t// Remove leading and trailing slashes, if any\r\n\t\tlet pattern = path.replace(SLASHES_REGEXP, \"\");\r\n\r\n\t\t// Save tokens\r\n\t\tpattern = replaceTokens(pattern, \"rgx\", \"save\");\r\n\t\t// Restore tokens\r\n\t\tpattern = replaceTokens(pattern, \"rRestore\", \"res\");\r\n\r\n\t\t// Add optional leading and trailing slashes\r\n\t\tpattern = \"\\\\/?\" + pattern + \"\\\\/?\";\r\n\r\n\t\treturn new RegExp(\"^\" + pattern + \"$\");\r\n\t};\r\n\r\n\t/**\r\n\t * Extract matching values out of a given path using a specified RegExp\r\n\t * @param {RegExp} regex\r\n\t * @param  {String} path\r\n\t * @return {Array}\r\n\t */\r\n\tconst extractValues = function(regex, path){\r\n\t\tconst values = [];\r\n\t\tlet match;\r\n\t\t// Reset lastIndex since RegExp can have \"g\" flag thus multiple runs might affect the result\r\n\t\tregex.lastIndex = 0;\r\n\t\twhile((match = regex.exec(path)) !== null){\r\n\t\t\tvalues.push(match[1]);\r\n\t\t}\r\n\t\treturn values;\r\n\t};\r\n\r\n\t/**\r\n\t * Extract an array of id out of a given path\r\n\t * @param {String} path\r\n\t * @return {Array}\r\n\t */\r\n\tluga.router.utils.getParamIds = function(path){\r\n\t\treturn extractValues(PARAMS_REGEXP, path);\r\n\t};\r\n\r\n\t/**\r\n\t * Extract an array of values out of a given path using a RegExp\r\n\t * @param {String} fragment\r\n\t * @param {RegExp} regex\r\n\t * @return {Array}\r\n\t */\r\n\tluga.router.utils.getParamValues = function(fragment, regex){\r\n\t\tconst values = regex.exec(fragment);\r\n\t\t/* istanbul ignore else */\r\n\t\tif(values !== null){\r\n\t\t\t// We want a plain vanilla array, normalize the result object\r\n\t\t\tvalues.shift();\r\n\t\t\tdelete values.index;\r\n\t\t\tdelete values.input;\r\n\t\t\tdelete values.groups;\r\n\t\t}\r\n\t\treturn values;\r\n\t};\r\n\r\n}());","/**\r\n * @typedef {Object} luga.router.options\r\n *\r\n * @property {String} rootPath                 Default to empty string\r\n * @property {function} handlerConstructor     Constructor of routeHandler class. Must implement IRouteHandler. Default to luga.router.RouteHandler\r\n * @property {Boolean} greedy                  Set it to true to allow multiple routes matching. Default to false\r\n * @property {Boolean} pushState               Set it to true if you want to list to window.popstate. Default to false and listen to window.hashchange instead\r\n */\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * Router class\r\n\t * @param {luga.router.options|undefined} options\r\n\t * @constructor\r\n\t * @extends luga.Notifier\r\n\t * @fires routeEntered\r\n\t * @fires routeExited\r\n\t */\r\n\tluga.router.Router = function(options){\r\n\r\n\t\tconst CONST = {\r\n\t\t\tERROR_MESSAGES: {\r\n\t\t\t\tINVALID_ROUTE: \"luga.router.Router: Invalid route passed to .add() method\",\r\n\t\t\t\tINVALID_ADD_ARGUMENTS: \"luga.router.Router: Invalid arguments passed to .add() method\",\r\n\t\t\t\tDUPLICATE_ROUTE: \"luga.router.Router: Duplicate route, path {0} already specified\"\r\n\t\t\t},\r\n\t\t\tEVENTS: {\r\n\t\t\t\tENTER: \"routeEntered\",\r\n\t\t\t\tEXIT: \"routeExited\"\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tluga.extend(luga.Notifier, this);\r\n\r\n\t\t/**\r\n\t\t * @type {luga.router.options}\r\n\t\t */\r\n\t\tconst config = {\r\n\t\t\trootPath: \"\",\r\n\t\t\thandlerConstructor: luga.router.RouteHandler,\r\n\t\t\tgreedy: false,\r\n\t\t\tpushState: false\r\n\t\t};\r\n\r\n\t\tluga.merge(config, options);\r\n\r\n\t\t/** @type {luga.router.Router} */\r\n\t\tconst self = this;\r\n\r\n\t\t/** @type {Array.<luga.router.IRouteHandler>} */\r\n\t\tlet routeHandlers = [];\r\n\r\n\t\t/** @type {String|undefined} */\r\n\t\tlet currentFragment;\r\n\r\n\t\t/** @type {Array.<luga.router.IRouteHandler>} */\r\n\t\tlet currentHandlers = [];\r\n\r\n\t\t/**\r\n\t\t * Add a route. It can be invoked with two different sets of arguments:\r\n\t\t * 1) A path expressed as a string, plus additional optional arguments\r\n\t\t *\r\n\t\t * 2) One routeHandler object:\r\n\t\t * ex: Router.add({luga.router.IRouteHandler})\r\n\t\t *\r\n\t\t *\r\n\t\t * @param {String|luga.router.IRouteHandler} path        Either a routeHandler object or a path expressed as string. Required\r\n\t\t * @param {Function|array.<function>} [enterCallBack]   Either a single callBack function or an array of functions to be invoked before entering the route. Optional\r\n\t\t * @param {Function|array.<function>} [exitCallBack]     Either a single callBack function or an array of functions to be invoked before leaving the route. Optional\r\n\t\t * @param {Object} [payload]                             A payload object to be passed to the callBacks. Optional\r\n\t\t */\r\n\t\tthis.add = function(path, enterCallBack, exitCallBack, payload){\r\n\t\t\tif(arguments.length === 1){\r\n\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\tif((luga.type(arguments[0]) !== \"string\") && (luga.type(arguments[0]) !== \"object\")){\r\n\t\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_ADD_ARGUMENTS);\r\n\t\t\t\t}\r\n\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\tif(luga.type(arguments[0]) === \"object\"){\r\n\t\t\t\t\tif(luga.router.isValidRouteHandler(arguments[0]) !== true){\r\n\t\t\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_ROUTE);\r\n\t\t\t\t\t}\r\n\t\t\t\t\taddHandler(arguments[0]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif((arguments.length > 1) && (luga.router.isValidRouteHandler(arguments[0]) === true)){\r\n\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_ADD_ARGUMENTS);\r\n\t\t\t}\r\n\t\t\tif((arguments.length > 0) && (luga.type(arguments[0]) === \"string\")){\r\n\t\t\t\tconst handlerOptions = {\r\n\t\t\t\t\tpath: path,\r\n\t\t\t\t\tenterCallBacks: [],\r\n\t\t\t\t\texitCallBacks: [],\r\n\t\t\t\t\tpayload: payload\r\n\t\t\t\t};\r\n\t\t\t\tif(luga.type(enterCallBack) === \"array\"){\r\n\t\t\t\t\thandlerOptions.enterCallBacks = enterCallBack;\r\n\t\t\t\t}\r\n\t\t\t\tif(luga.type(enterCallBack) === \"function\"){\r\n\t\t\t\t\thandlerOptions.enterCallBacks = [enterCallBack];\r\n\t\t\t\t}\r\n\t\t\t\tif(luga.type(exitCallBack) === \"array\"){\r\n\t\t\t\t\thandlerOptions.exitCallBacks = exitCallBack;\r\n\t\t\t\t}\r\n\t\t\t\tif(luga.type(exitCallBack) === \"function\"){\r\n\t\t\t\t\thandlerOptions.exitCallBacks = [exitCallBack];\r\n\t\t\t\t}\r\n\t\t\t\tconst handler = new config.handlerConstructor(handlerOptions);\r\n\t\t\t\taddHandler(handler);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * @param {luga.router.IRouteHandler} route\r\n\t\t */\r\n\t\tconst addHandler = function(route){\r\n\t\t\tif(self.getByPath(route.path) !== undefined){\r\n\t\t\t\tthrow(luga.string.format(CONST.ERROR_MESSAGES.DUPLICATE_ROUTE, [route.path]));\r\n\t\t\t}\r\n\t\t\trouteHandlers.push(route);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return all the available route objects\r\n\t\t * @return {Array.<luga.router.IRouteHandler>}\r\n\t\t */\r\n\t\tthis.getAll = function(){\r\n\t\t\treturn routeHandlers;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return a registered route object associated with the given path\r\n\t\t * Return undefined if none is fund\r\n\t\t * @param {String} path\r\n\t\t * @return {luga.router.IRouteHandler|undefined}\r\n\t\t */\r\n\t\tthis.getByPath = function(path){\r\n\t\t\tfor(let i = 0; i < routeHandlers.length; i++){\r\n\t\t\t\tif(routeHandlers[i].path === path){\r\n\t\t\t\t\treturn routeHandlers[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * If options.greedy is false either:\r\n\t\t * 1) Return a registered routeHandler object matching the given fragment\r\n\t\t * 2) Return undefined if none is fund\r\n\t\t *\r\n\t\t * If options.greedy is true either:\r\n\t\t * 1) Return an array of matching routeHandler objects\r\n\t\t * 2) Return an empty array if none is fund\r\n\t\t *\r\n\t\t * @param {String} fragment\r\n\t\t * @return {luga.router.IRouteHandler|undefined|array.<luga.router.IRouteHandler>}\r\n\t\t */\r\n\t\tthis.getMatch = function(fragment){\r\n\t\t\tif(config.greedy === false){\r\n\t\t\t\tfor(let i = 0; i < routeHandlers.length; i++){\r\n\t\t\t\t\tif(routeHandlers[i].match(fragment) === true){\r\n\t\t\t\t\t\treturn routeHandlers[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\treturn routeHandlers.filter(function(element, index, array){\r\n\t\t\t\t\treturn element.match(fragment) === true;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Remove the rootPath in front of the given string\r\n\t\t * Also remove the querystring, if any\r\n\t\t * @param {String} inputString\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tthis.normalizeFragment = function(inputString){\r\n\t\t\tif(inputString.indexOf(\"?\") !== -1){\r\n\t\t\t\tinputString = inputString.substring(0, inputString.indexOf(\"?\"));\r\n\t\t\t}\r\n\t\t\tconst pattern = new RegExp(\"^\\/?\" + config.rootPath);\r\n\t\t\treturn inputString.replace(pattern, \"\");\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Remove any '#' and/or '!' in front of the given string\r\n\t\t * Then remove the rootPath too\r\n\t\t * @param {String} inputString\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tthis.normalizeHash = function(inputString){\r\n\t\t\tif(inputString[0] === \"#\"){\r\n\t\t\t\tinputString = inputString.substring(1);\r\n\t\t\t}\r\n\t\t\tif(inputString[0] === \"!\"){\r\n\t\t\t\tinputString = inputString.substring(1);\r\n\t\t\t}\r\n\t\t\treturn self.normalizeFragment(inputString);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Remove the routeHandler matching the given path\r\n\t\t * Fails silently if the given path does not match any routeHandler\r\n\t\t * @param {String} path\r\n\t\t */\r\n\t\tthis.remove = function(path){\r\n\t\t\tconst index = routeHandlers.indexOf(self.getByPath(path));\r\n\t\t\tif(index !== -1){\r\n\t\t\t\trouteHandlers.splice(index, 1);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Remove all routeHandlers\r\n\t\t */\r\n\t\tthis.removeAll = function(){\r\n\t\t\trouteHandlers = [];\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * If options.greedy is false either fails silently if no match is fund or:\r\n\t\t * 1) Call the exit() method of the previously matched routeHandler\r\n\t\t * 2) Call the enter() method of the first registered routeHandler matching the given fragment\r\n\t\t *\r\n\t\t * If options.greedy is true either fails silently if no match is fund or:\r\n\t\t * 1) Call the exit() method of the previously matched routeHandlers\r\n\t\t * 2) Call the enter() method of all the registered routeHandlers matching the given fragment\r\n\t\t *\r\n\t\t * @param {String} fragment\r\n\t\t * @param {Object|undefined} resOptions\r\n\t\t * @return {Boolean} True if at least one routeHandler was resolved, false otherwise\r\n\t\t */\r\n\t\tthis.resolve = function(fragment, resOptions){\r\n\t\t\tlet matches = self.getMatch(fragment);\r\n\t\t\tif(matches === undefined){\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t// Single match\r\n\t\t\tif(luga.type(matches) !== \"array\"){\r\n\t\t\t\tmatches = [matches];\r\n\t\t\t}\r\n\t\t\texit(resOptions);\r\n\t\t\tenter(matches, fragment, resOptions);\r\n\t\t\treturn matches.length > 0;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Overwrite the current handlers with the given ones\r\n\t\t * Then execute the enter() method on each of them\r\n\t\t * Finally: triggers a 'routeEntered' notification\r\n\t\t * @param {Array.<luga.router.IRouteHandler>} handlers\r\n\t\t * @param {String} fragment\r\n\t\t * @param {Object} enterOptions\r\n\t\t */\r\n\t\tconst enter = function(handlers, fragment, enterOptions){\r\n\t\t\tcurrentHandlers = handlers;\r\n\t\t\tcurrentFragment = fragment;\r\n\t\t\tcurrentHandlers.forEach(function(element){\r\n\t\t\t\tconst context = assembleContext(element, fragment, enterOptions);\r\n\t\t\t\telement.enter(context);\r\n\t\t\t\tself.notifyObservers(CONST.EVENTS.ENTER, context);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Execute the exit() method on all the current handlers\r\n\t\t */\r\n\t\tconst exit = function(){\r\n\t\t\tcurrentHandlers.forEach(function(element){\r\n\t\t\t\tconst context = assembleContext(element, currentFragment, options);\r\n\t\t\t\telement.exit(context);\r\n\t\t\t\tself.notifyObservers(CONST.EVENTS.EXIT, {});\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Assemble a route context\r\n\t\t * @param {luga.router.IRouteHandler} handler\r\n\t\t * @param {String} fragment\r\n\t\t * @param {Object} contextOptions\r\n\t\t * @return {luga.router.routeContext}\r\n\t\t */\r\n\t\tconst assembleContext = function(handler, fragment, contextOptions){\r\n\t\t\t/** @type {luga.router.routeContext} */\r\n\t\t\tconst context = {\r\n\t\t\t\tfragment: fragment,\r\n\t\t\t\tpath: handler.path,\r\n\t\t\t\tpayload: handler.getPayload(),\r\n\t\t\t\tparams: handler.getParams(fragment),\r\n\t\t\t\thistoryState: undefined\r\n\t\t\t};\r\n\r\n\t\t\tluga.merge(context, contextOptions);\r\n\t\t\treturn context;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Change current configuration\r\n\t\t * @param {luga.router.options} setupOptions\r\n\t\t * @return {luga.router.options}\r\n\t\t */\r\n\t\tthis.setup = function(setupOptions){\r\n\t\t\tluga.merge(config, setupOptions);\r\n\t\t\treturn config;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Bootstrap the Router\r\n\t\t * If inside a browser, start listening to the \"hashchange\" and \"popstate\" events\r\n\t\t */\r\n\t\tthis.start = function(){\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif(window !== undefined){\r\n\t\t\t\tif(config.pushState === false){\r\n\t\t\t\t\twindow.addEventListener(\"hashchange\", self.onHashChange, false);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\twindow.addEventListener(\"popstate\", self.onPopstate, false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Stop the Router\r\n\t\t * If inside a browser, stop listening to the \"hashchange\" and \"popstate\" events\r\n\t\t */\r\n\t\tthis.stop = function(){\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif(window !== undefined){\r\n\t\t\t\tif(config.pushState === false){\r\n\t\t\t\t\twindow.removeEventListener(\"hashchange\", self.onHashChange, false);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\twindow.removeEventListener(\"popstate\", self.onPopstate, false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Handle a hashchange event\r\n\t\t * https://developer.mozilla.org/en-US/docs/Web/API/HashChangeEvent\r\n\t\t */\r\n\t\tthis.onHashChange = function(){\r\n\t\t\tself.resolve(self.normalizeHash(location.hash));\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Handle a popstate event\r\n\t\t * https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate\r\n\t\t * @param {event} event\r\n\t\t */\r\n\t\tthis.onPopstate = function(event){\r\n\t\t\tconst fragment = self.normalizeFragment(document.location.pathname);\r\n\t\t\tself.resolve(fragment, {historyState: event.state});\r\n\t\t};\r\n\r\n\t};\r\n\r\n}());","(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * Route class\r\n\t * @param options {luga.router.IRouteHandler.options}\r\n\t * @constructor\r\n\t * @implements luga.router.IRouteHandler\r\n\t */\r\n\tluga.router.RouteHandler = function(options){\r\n\r\n\t\tconst CONST = {\r\n\t\t\tERROR_MESSAGES: {\r\n\t\t\t\tINVALID_PATH_REGEXP: \"luga.router.RouteHandler: Invalid path. You must use strings, RegExp are not allowed\"\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * @type {luga.router.IRouteHandler.options}\r\n\t\t */\r\n\t\tconst config = {\r\n\t\t\tpath: \"\",\r\n\t\t\tenterCallBacks: [],\r\n\t\t\texitCallBacks: [],\r\n\t\t\tpayload: undefined\r\n\t\t};\r\n\r\n\t\tluga.merge(config, options);\r\n\t\tif(luga.type(config.enterCallBacks) === \"function\"){\r\n\t\t\tconfig.enterCallBacks = [config.enterCallBacks];\r\n\t\t}\r\n\t\tif(luga.type(config.exitCallBacks) === \"function\"){\r\n\t\t\tconfig.exitCallBacks = [config.exitCallBacks];\r\n\t\t}\r\n\r\n\t\tif(luga.type(config.path) === \"regexp\"){\r\n\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_PATH_REGEXP);\r\n\t\t}\r\n\r\n\t\tthis.path = config.path;\r\n\r\n\t\t/** @type {RegExp} */\r\n\t\tconst compiledPath = luga.router.utils.compilePath(this.path);\r\n\r\n\t\t/** @type {Array} */\r\n\t\tconst paramsId = luga.router.utils.getParamIds(this.path);\r\n\r\n\t\t/**\r\n\t\t * Execute registered enter callbacks, if any\r\n\t\t * @param {luga.router.routeContext} context\r\n\t\t */\r\n\t\tthis.enter = function(context){\r\n\t\t\tconfig.enterCallBacks.forEach(function(element){\r\n\t\t\t\telement.apply(null, [context]);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Execute registered exit callbacks, if any\r\n\t\t */\r\n\t\tthis.exit = function(){\r\n\t\t\tconfig.exitCallBacks.forEach(function(element){\r\n\t\t\t\telement.apply(null, []);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return an object containing an entry for each param and the relevant values extracted from the fragment\r\n\t\t * @param {String} fragment\r\n\t\t * @return {Object}\r\n\t\t */\r\n\t\tthis.getParams = function(fragment){\r\n\t\t\tconst ret = {};\r\n\t\t\tconst values = luga.router.utils.getParamValues(fragment, compiledPath);\r\n\t\t\t// Merge the two parallel arrays\r\n\t\t\tparamsId.forEach(function(element, i){\r\n\t\t\t\tret[element] = values[i];\r\n\t\t\t});\r\n\t\t\treturn ret;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return the handler payload, if any\r\n\t\t * Return undefined if no payload is associated with the handler\r\n\t\t * @return {luga.router.routeContext|undefined}\r\n\t\t */\r\n\t\tthis.getPayload = function(){\r\n\t\t\treturn config.payload;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return true if the given fragment matches the Route. False otherwise\r\n\t\t * @param {String}  fragment\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tthis.match = function(fragment){\r\n\t\t\treturn compiledPath.test(fragment);\r\n\t\t};\r\n\r\n\t};\r\n\r\n}());","(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * @typedef {Object} luga.history.options\r\n\t *\r\n\t * @property {Boolean} pushState  Determine if we use pushState or the location hash. Default to false. If pushState is not available (like in IE9) the location hash will be used anyway\r\n\t */\r\n\r\n\tluga.namespace(\"luga.history\");\r\n\r\n\t/**\r\n\t * @type {luga.history.options}\r\n\t */\r\n\tconst settings = {\r\n\t\tpushState: false\r\n\t};\r\n\r\n\t/**\r\n\t * Change current configuration\r\n\t * @param {luga.history.options} options\r\n\t * @return {luga.history.options}\r\n\t */\r\n\tluga.history.setup = function(options){\r\n\t\tluga.merge(settings, options);\r\n\t\treturn settings;\r\n\t};\r\n\r\n\t/**\r\n\t * Return true if are using pushState, false otherwise\r\n\t * The result depend on a combination of browser capabilities and current configuration\r\n\t * @return {Boolean}\r\n\t */\r\n\tluga.history.usePushState = function(){\r\n\t\treturn settings.pushState === true;\r\n\t};\r\n\r\n\t/**\r\n\t * @typedef {Object} luga.history.navigate.options\r\n\t *\r\n\t * @property {Boolean} replace  Determine if we add a new history entry or replace the current one\r\n\t * @property {String}  title    Title to be passed to pushState. Default to empty string. Some browser don't support this yet\r\n\t * @property {Object}  state    A JavaScript object which is associated with the new history entry. Default to an empty object. See:\r\n\t *                              https://developer.mozilla.org/en-US/docs/Web/API/History_API#The_pushState()_method\r\n\t */\r\n\r\n\t/**\r\n\t * Add an entry to the browser's history or modify the current entry\r\n\t * https://developer.mozilla.org/en-US/docs/Web/API/History_API\r\n\t * @param {String} fragment\r\n\t * @param {luga.history.navigate.options} options\r\n\t */\r\n\tluga.history.navigate = function(fragment, options){\r\n\t\tconst config = {\r\n\t\t\treplace: false,\r\n\t\t\ttitle: \"\",\r\n\t\t\tstate: {}\r\n\t\t};\r\n\t\tluga.merge(config, options);\r\n\r\n\t\t// pushState\r\n\t\tif(luga.history.usePushState() === true){\r\n\t\t\tlet historyMethod = \"pushState\";\r\n\t\t\tif(config.replace === true){\r\n\t\t\t\thistoryMethod = \"replaceState\";\r\n\t\t\t}\r\n\t\t\thistory[historyMethod](config.state, config.title, fragment);\r\n\t\t}\r\n\t\t// location hash\r\n\t\telse{\r\n\t\t\tif(config.replace === true){\r\n\t\t\t\tconst newLocation = location.href.replace(/(javascript:|#).*$/, \"\");\r\n\t\t\t\tlocation.replace(newLocation  + \"#\" + fragment);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\t// Some browsers require that location hash contains a leading #\r\n\t\t\t\tlocation.hash = \"#\" + fragment;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n}());"],"sourceRoot":"."}